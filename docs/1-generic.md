# generics

- can't do anything with a type (but refer to subparts) without interfaces
- core interfaces
  - equality
    - separate from ordering because can short-circuit
    - `Eq` + `PartialEq`
    - TODO: find a way to make `float` totally comparable so that `find` can work
  - order (relates to equality)
    - `Ord` + `PartialOrd`
    - TODO: find a way to make `float` ordered enough for sort to be defined
  - copy (relates to equality)
    - rust has `Copy` for implicit bit-copying and `Clone` for the "real thing"
      - we can instead have a marker "Moved-from value is still good"?
      - rust `Copy` is incompatible with `Drop`
      - rust `Clone` has `clone_from` aka copy-assignment
        - but the compiler does not auto-rewrite `a = b.clone()` into `a.clone_from(&b)`
          - the difference is observable; can we spec a way around this?
  - hash (relates to equality)
    - requires a templated function (accepts a `Hasher`)
  - default
    - do we need it? or is zero-init a good enough behavior?
  - debug
    - can we auto-generate a debug that is structural and suitable for UI automatically? what annotations do we need for that?
      - we probably want to have enough information about the type to generate most of the traits automatically
  - drop
  - deref (`fn deref(&self) -> &Self::Target`)
  - serialize/unserialize
  - Into + AsRef; Borrow
  - magic:
    - `Sized`: implicit bound everywhere
    - `Pin` for self-referential data (can't get underlying mutable reference); `Unpin` is auto (and default)
      - `pin-project` uses annotations to project a pinned version of your data type
      - pin is a hack; a language should know that there are non-moveable types
        - or better, avoid this altogether with proper lightweight threads
    - `Send` (auto)
    - `Sync` (auto)
- common theme: "implement once" for a type, visiting subparts; can customize later, by using different visitors
  - hash with different hasher
  - serialize in a different format
  - compare with a different element comparison
  - can we encode this with e.g. an auto-generated enum list, describing subparts?
    - some "subparts" can be virtual, think slices etc.
    - kind of like Boost.Describe does
- sealed (user should not implement) vs open (user should implement) trairs
- magical things that should not be overridable; things that establish or maintain invariants:
  - constructors
  - destructors
- to think:
  - models can be stateful; C++ comparator objects can provide that
    - for data types (think `set`), need to store the model!
    - for functions (think `sort`), need an easy way to pass the model
    - comparator: `T: Ord[Int]` (natural model = `Int: Ord[Int]`)
  - associated types vs generic traits:
    - rust: trait params = input (`Add<Rhs>`); associated types = outputs (`Add<Rhs> { type Sum }`)
      - when trait has a parameter, it can be implemented multuple times; not what we usually want
