# start over from fuzzing

- auto-testing via fuzzing is our magic trick, so start with it and don't care about the language
  - or rather, build the language around the fuzzing needs
- what we want
  - liberal use of assertions
  - immediate full coverage (that's the magic)
  - any uncovered statement/expression is a warning
  - to fix these, people will write "scenarios" (which we turn into property-based tests)
    - an abstract example of how the package code can be used
    - abstract constants for everything; explicit arbitrary choice
- how do we get there
  - package-aware fuzzing, only fuzz a package at a time
    - only care about coverage of the current package
    - design for guiding people towards approach like https://matklad.github.io/2021/05/31/how-to-test.html
  - structure-aware fuzzing, always fuzz rich data with rich semantic edits
    - structure-aware taint tracking
    - maybe even bits of structure-aware symbolic execution
  - explicit arbitrary choice
    - constants in code and in test scenarios
    - choice of actions in test scenarios
  - statement to signal progress to a fuzzer to help guide the search
