# misc

- iteration via generators

- references & values
  - ownership/values: regular, `boxed` (?), `shared`, `weak` (`unowned`?)
  - only references:
    - default mode means different things
      - owning reference `T @own` default for structs
      - mutable reference; need explicit target for structs
      - immutable reference `T` default for params; need explicit target for structs
  - `mutable`

- core
  - values (= places in memory)
    - values have type (= layout)
    - values have subparts (whole/part relationship); we can refer to subparts (= fields)
      - `.field`
    - values have alternatives (enums); can refer to an alternative (= variant)?
      - `~variant`
        - this is just a typecast, isn't it?
          - well, if we check the place where we witness the location, then this is a type assertion witness!
        - or use `.variant` and reserve `~` for negation later?
          - this is consistent with swift-like enum variants
      - unclear what is the meaning
        - for borrowing, borrow of one variant borrows any variants
        - for views, is this a conditional view?
        - in general, this is an obligation on that some variable is in some specific state; do we want that?
    - need to unify enums and structs to allow to model OO-like or FP-like (like rust virtual struct idea)
      - need a smooth way up from a "just enum" to "enum with data"
      - also a smooth way up from "just a struct" to "actually there are variants that share some common fields"
        - also want a smooth way to transition from concrete type to an interface/trait
          - traits can have virtual fields?
      - need an explicit way to require "unsized" (class-like) enums?
        - hey, they are true unsized only if we allow to extend openly; otherwise they are just variable-sized
        - shouldn't the client choose between a layout for "base" enum?
          - EASY! full-inline-layout is just an in-place box (which requires biggest-size)
          - and out-of-place box does not require the biggest size
            - `boxed[T]` uses only as much as required for each variant
              - same with `shared` and `weak`
            - `inplace[T]` uses the biggest size for all variants (because no indirection)
            - this is one more place where we can be better than rust because our `box` is more magical?
      - traits should be the same, but with vtables and open extensibility by default
        - non-object-safe traits should not be the default
  - location
    - location = `@(a.foo | b.bar)`
    - location = some fuzzy combination of possible places
    - locations can be unioned or intersected, giving locations
  - references to views of values @ locations
    - locations = witnesses of existence and of that we uphold borrow rules
      - do they play well with use cases like "parametrize by arena lifetime" in rust?
    - can be complex: `@(a | b, c)`
    - can refer to subparts only
      - using location syntax!
        - but, this is "relative" (to self) location, @ part needs to specify rooted (absolute) locations
        - for subparts, we usually want `.A, .B, .C` == `A and B and C`
        - for reference locations, we usually want `a.A | b.B` == `a.A or b.B`
    - can be
      - owning (refers to self-place with the same name)
      - mutably borrowed (from some place we need to name)
      - immutably borrowed (from some place we need to name)

- types
  - primitive (atomic) types
  - types can be grouped (as fields) into structs (always inline)
  - types can be alternated (as variants) into enums (always outline? not ergonomic for plain enums)
    - common parts are shared/reused and reside in "parent" (enum itself)
      - need a way to refer to the common bits separately from
    - variants are always a distinct types, which can be separately used
  - open vs exhaustive enums
    - can force to pattern-match on unknown cases always

- boxes and indirection
  - is `box[T]` a real type, or is this just an annotation on `T` reference in struct that we would like it to be stored indirectly?
